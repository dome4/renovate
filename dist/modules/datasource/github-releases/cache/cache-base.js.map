{"version":3,"file":"cache-base.js","sourceRoot":"","sources":["../../../../../lib/modules/datasource/github-releases/cache/cache-base.ts"],"names":[],"mappings":"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","sourcesContent":["import { DateTime, DurationLikeObject } from 'luxon';\nimport * as packageCache from '../../../../util/cache/package';\nimport type {\n  GithubGraphqlResponse,\n  GithubHttp,\n} from '../../../../util/http/github';\nimport type { GetReleasesConfig } from '../../types';\nimport { getApiBaseUrl } from '../common';\nimport type {\n  CacheOptions,\n  GithubDatasourceCache,\n  GithubQueryParams,\n  QueryResponse,\n  StoredItemBase,\n} from './types';\n\n/**\n * The options that are meant to be used in production.\n */\nconst cacheDefaults: Required<CacheOptions> = {\n  /**\n   * How many minutes to wait until next cache update\n   */\n  updateAfterMinutes: 120,\n\n  /**\n   * If package was released recently, we assume higher\n   * probability of having one more release soon.\n   *\n   * In this case, we use `updateAfterMinutesFresh` option.\n   */\n  packageFreshDays: 7,\n\n  /**\n   * If package was released recently, we assume higher\n   * probability of having one more release soon.\n   *\n   * In this case, this option will be used\n   * instead of `updateAfterMinutes`.\n   *\n   * Fresh period is configured via `freshDays` option.\n   */\n  updateAfterMinutesFresh: 30,\n\n  /**\n   * How many days to wait until full cache reset (for single package).\n   */\n  resetAfterDays: 7,\n\n  /**\n   * Delays cache reset by some random amount of minutes,\n   * in order to stabilize load during mass cache reset.\n   */\n  resetDeltaMinutes: 3 * 60,\n\n  /**\n   * How many days ago the package should be published to be considered as stable.\n   * Since this period is expired, it won't be refreshed via soft updates anymore.\n   */\n  unstableDays: 30,\n\n  /**\n   * How many items per page to obtain per page during initial fetch (i.e. pre-fetch)\n   */\n  itemsPerPrefetchPage: 100,\n\n  /**\n   * How many pages to fetch (at most) during the initial fetch (i.e. pre-fetch)\n   */\n  maxPrefetchPages: 100,\n\n  /**\n   * How many items per page to obtain per page during the soft update\n   */\n  itemsPerUpdatePage: 100,\n\n  /**\n   * How many pages to fetch (at most) during the soft update\n   */\n  maxUpdatePages: 100,\n};\n\n/**\n * Tells whether the time `duration` is expired starting\n * from the `date` (ISO date format) at the moment of `now`.\n */\nfunction isExpired(\n  now: DateTime,\n  date: string,\n  duration: DurationLikeObject\n): boolean {\n  const then = DateTime.fromISO(date);\n  const expiry = then.plus(duration);\n  return now >= expiry;\n}\n\nexport abstract class AbstractGithubDatasourceCache<\n  StoredItem extends StoredItemBase,\n  FetchedItem = unknown\n> {\n  private updateDuration: DurationLikeObject;\n  private packageFreshDaysDuration: DurationLikeObject;\n  private updateDurationFresh: DurationLikeObject;\n  private resetDuration: DurationLikeObject;\n  private stabilityDuration: DurationLikeObject;\n\n  private maxPrefetchPages: number;\n  private itemsPerPrefetchPage: number;\n\n  private maxUpdatePages: number;\n  private itemsPerUpdatePage: number;\n\n  private resetDeltaMinutes: number;\n\n  constructor(private http: GithubHttp, opts: CacheOptions = {}) {\n    const {\n      updateAfterMinutes,\n      packageFreshDays,\n      updateAfterMinutesFresh,\n      resetAfterDays,\n      unstableDays,\n      maxPrefetchPages,\n      itemsPerPrefetchPage,\n      maxUpdatePages,\n      itemsPerUpdatePage,\n      resetDeltaMinutes,\n    } = {\n      ...cacheDefaults,\n      ...opts,\n    };\n\n    this.updateDuration = { minutes: updateAfterMinutes };\n    this.packageFreshDaysDuration = { days: packageFreshDays };\n    this.updateDurationFresh = { minutes: updateAfterMinutesFresh };\n    this.resetDuration = { days: resetAfterDays };\n    this.stabilityDuration = { days: unstableDays };\n\n    this.maxPrefetchPages = maxPrefetchPages;\n    this.itemsPerPrefetchPage = itemsPerPrefetchPage;\n    this.maxUpdatePages = maxUpdatePages;\n    this.itemsPerUpdatePage = itemsPerUpdatePage;\n\n    this.resetDeltaMinutes = resetDeltaMinutes;\n  }\n\n  /**\n   * The key at which data is stored in the package cache.\n   */\n  abstract readonly cacheNs: string;\n\n  /**\n   * The query string.\n   * For parameters, see `GithubQueryParams`.\n   */\n  abstract readonly graphqlQuery: string;\n\n  /**\n   * Transform `fetchedItem` for storing in the package cache.\n   * @param fetchedItem Node obtained from GraphQL response\n   */\n  abstract coerceFetched(fetchedItem: FetchedItem): StoredItem | null;\n\n  /**\n   * Pre-fetch, update, or just return the package cache items.\n   */\n  async getItems(releasesConfig: GetReleasesConfig): Promise<StoredItem[]> {\n    const { packageName, registryUrl } = releasesConfig;\n\n    // The time meant to be used across the function\n    const now = DateTime.now();\n\n    // Initialize items and timestamps for the new cache\n    let cacheItems: Record<string, StoredItem> = {};\n\n    // Add random minutes to the creation date in order to\n    // provide back-off time during mass cache invalidation.\n    const randomDelta = this.getRandomDeltaMinutes();\n    let cacheCreatedAt = now.plus(randomDelta).toISO();\n\n    // We have to initialize `updatedAt` value as already expired,\n    // so that soft update mechanics is immediately starting.\n    let cacheUpdatedAt = now.minus(this.updateDuration).toISO();\n\n    const baseUrl = getApiBaseUrl(registryUrl).replace('/v3/', '/'); // Replace for GHE\n\n    const [owner, name] = packageName.split('/');\n    if (owner && name) {\n      const cacheKey = `${baseUrl}:${owner}:${name}`;\n      const cache = await packageCache.get<GithubDatasourceCache<StoredItem>>(\n        this.cacheNs,\n        cacheKey\n      );\n\n      const cacheDoesExist =\n        cache && !isExpired(now, cache.createdAt, this.resetDuration);\n      let lastReleasedAt: string | null = null;\n      let updateDuration = this.updateDuration;\n      if (cacheDoesExist) {\n        // Keeping the the original `cache` value intact\n        // in order to be used in exception handler\n        cacheItems = { ...cache.items };\n        cacheCreatedAt = cache.createdAt;\n        cacheUpdatedAt = cache.updatedAt;\n        lastReleasedAt =\n          cache.lastReleasedAt ?? this.getLastReleaseTimestamp(cacheItems);\n\n        // Release is considered fresh, so we'll check it earlier\n        if (\n          lastReleasedAt &&\n          !isExpired(now, lastReleasedAt, this.packageFreshDaysDuration)\n        ) {\n          updateDuration = this.updateDurationFresh;\n        }\n      }\n\n      if (isExpired(now, cacheUpdatedAt, updateDuration)) {\n        const variables: GithubQueryParams = {\n          owner,\n          name,\n          cursor: null,\n          count: cacheDoesExist\n            ? this.itemsPerUpdatePage\n            : this.itemsPerPrefetchPage,\n        };\n\n        // Collect version values to determine deleted items\n        const checkedVersions = new Set<string>();\n\n        // Page-by-page update loop\n        let pagesRemained = cacheDoesExist\n          ? this.maxUpdatePages\n          : this.maxPrefetchPages;\n        let stopIteration = false;\n        while (pagesRemained > 0 && !stopIteration) {\n          const graphqlRes = await this.http.postJson<\n            GithubGraphqlResponse<QueryResponse<FetchedItem>>\n          >('/graphql', {\n            baseUrl,\n            body: { query: this.graphqlQuery, variables },\n          });\n          pagesRemained -= 1;\n\n          const { data, errors } = graphqlRes.body;\n\n          const errorMessage = errors?.[0]?.message;\n          if (errorMessage) {\n            throw Error(errorMessage);\n          }\n\n          if (data) {\n            const {\n              nodes: fetchedItems,\n              pageInfo: { hasNextPage, endCursor },\n            } = data.repository.payload;\n\n            if (hasNextPage) {\n              variables.cursor = endCursor;\n            } else {\n              stopIteration = true;\n            }\n\n            for (const item of fetchedItems) {\n              const newStoredItem = this.coerceFetched(item);\n              if (newStoredItem) {\n                const { version, releaseTimestamp } = newStoredItem;\n\n                // Stop earlier if the stored item have reached stability,\n                // which means `unstableDays` period have passed\n                const oldStoredItem = cacheItems[version];\n                if (\n                  oldStoredItem &&\n                  isExpired(\n                    now,\n                    oldStoredItem.releaseTimestamp,\n                    this.stabilityDuration\n                  )\n                ) {\n                  stopIteration = true;\n                  break;\n                }\n\n                cacheItems[version] = newStoredItem;\n                checkedVersions.add(version);\n\n                lastReleasedAt ??= releaseTimestamp;\n                // It may be tempting to optimize the code and\n                // remove the check, as we're fetching fresh releases here.\n                // That's wrong, because some items are already cached,\n                // and they obviously aren't latest.\n                if (\n                  DateTime.fromISO(releaseTimestamp) >\n                  DateTime.fromISO(lastReleasedAt)\n                ) {\n                  lastReleasedAt = releaseTimestamp;\n                }\n              }\n            }\n          }\n        }\n\n        // Detect removed items\n        for (const [version, item] of Object.entries(cacheItems)) {\n          if (\n            !isExpired(now, item.releaseTimestamp, this.stabilityDuration) &&\n            !checkedVersions.has(version)\n          ) {\n            delete cacheItems[version];\n          }\n        }\n\n        // Store cache\n        const expiry = DateTime.fromISO(cacheCreatedAt).plus(\n          this.resetDuration\n        );\n        const { minutes: ttlMinutes } = expiry\n          .diff(now, ['minutes'])\n          .toObject();\n        if (ttlMinutes && ttlMinutes > 0) {\n          const cacheValue: GithubDatasourceCache<StoredItem> = {\n            items: cacheItems,\n            createdAt: cacheCreatedAt,\n            updatedAt: now.toISO(),\n          };\n\n          if (lastReleasedAt) {\n            cacheValue.lastReleasedAt = lastReleasedAt;\n          }\n\n          await packageCache.set(\n            this.cacheNs,\n            cacheKey,\n            cacheValue,\n            ttlMinutes\n          );\n        }\n      }\n    }\n\n    const items = Object.values(cacheItems);\n    return items;\n  }\n\n  getRandomDeltaMinutes(): number {\n    const rnd = Math.random();\n    return Math.floor(rnd * this.resetDeltaMinutes);\n  }\n\n  public getLastReleaseTimestamp(\n    items: Record<string, StoredItem>\n  ): string | null {\n    let result: string | null = null;\n    let latest: DateTime | null = null;\n\n    for (const { releaseTimestamp } of Object.values(items)) {\n      const timestamp = DateTime.fromISO(releaseTimestamp);\n\n      result ??= releaseTimestamp;\n      latest ??= timestamp;\n\n      if (timestamp > latest) {\n        result = releaseTimestamp;\n        latest = timestamp;\n      }\n    }\n\n    return result;\n  }\n}\n"]}